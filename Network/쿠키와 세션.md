# 쿠키(Cookie)와 세션(Session)


## HTTP 프로토콜 특징

- `클라이언트 서버 구조`
    - 클라이언트가 서버에 요청(request)을 보내면, 서버는 그에 대한 응답(response)를 보냄
- `비연결 지향(Connectionless)`
    - 클라이언트의 요청에 응답한 후에는 연결을 끊음(연결 유지 X)
    - 최소한의 자원으로 서버 유지
- `무상태(Stateless)`
    - 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나고, 서버는 클라이언트의 상태 정보를 보존하지 않음
    - 클라이언트가 요청할 때 필요한 데이터를 추가적으로 담아서 전송해야 함
        - 항상 같은 서버를 유지하지 않아도 됨
        - 응답 서버를 쉽게 바꿀 수 있어서 서버 확장성이 높음(무한한 서버 증설 가능)


**쿠키와 세션의 필요성**

- HTTP 프로토콜의 특징으로 모든 요청 간에는 의존관계가 없음
    - 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법 존재 X
- 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 함
    - 로그인을 진행한 후, 다른 서비스를 사용하기 위해 매번 로그인(인증)을 하는 상황 발생
-  클라이언트의 상태 정보를 유지할 필요가 있을 경우, `쿠키`와 `세션`을 활용해서 Stateful한 동작 구현 가능
    - 무상태를 지향하기 위해 매 요청마다 필요한 정보를 담아 서버와 통신하는 경우, 비용과 부하가 커질 수 있음


<br/>

## 쿠키(Cookie)

- 개념
    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일
    - 사용자 인증이 유효한 시간 명시 가능(유효시간이 정해지면 브라우저가 종료되어도 인증 유지)
    - 클라이언트의 상태 정보를 브라우저(로컬)에 저장하여 참조
- 구성 요소
    - 쿠키의 이름(name)
    - 쿠키의 값(value)
    - 쿠키의 유효시간(Expires)
    - 쿠키를 전송할 도메인 이름(Domain)
    - 쿠키를 전송할 요청 경로(Path)
- 동작 방식
    1. 웹브라우저가 서버에 요청
    2. 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성
    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송
    4. 전달받은 쿠키는 웹 브라우저가 관리, 다음 요청 때 쿠키를 HTTP 헤더에 자동으로 넣어서 전송
    5. 서버에서 쿠키 정보를 읽어 이전 상태 정보를 확인 후 응답
- 사용 예
    - 아이디, 비밀번호 저장
    - 쇼핑몰 장바구니


<br/>

## 세션(Session)

- 개념
    - 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지함
        - 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태
    - `쿠키`를 사용하여 값을 주고 받으며 클라이언트의 상태 정보를 유지함
        - 사용자 정보 파일을 쿠키는 브라우저에 저장하고, 세션은 서버측에서 관리
    - 사용자에 대한 정보를 서버에 두기 때문에, 사용자가 많아질수록 서버 메모리 많이 차지
    - 보안 면에서 쿠키보다 우수
- 동작 방식
    1. 웹브라우저가 서버에 요청
    2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함
    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송
    4. 웹브라우저는 부여된 Session ID를 쿠키에 저장해두고, 다음 요청 때마다 해당 쿠키를 HTTP 헤더에 넣어서 전송
    5. 서버는 Session ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답
        - 로그인을 하는 경우, 해당 Session ID의 로그인 상태를 유효한 값으로 바꿔 저장
        - 이후 요청에서 해당 Session ID를 가진 클라이언트는 로그인 상태가 유효하므로 별도의 로그인 없이 서비스 이용 가능
- 사용 예
    - 로그인

<br/>

**다중 서버 환경에서 세션 관리**

서버를 다중화했을 경우, 세션 불일치 이슈 발생

- Sticky Session (스티키 세션)
    - 클라이언트의 요청이 항상 해당 클라이언트의 세션이 저장된 서버로만 전달됨
        - 로드밸런서에서 요청 쿠키(Session ID)를 읽고 지정된 서버(세션이 있는)로만 요청을 전달함
        - 세션 정보가 없을 경우, 로드밸런서의 기본 알고리즘대로 요청 전달
- Session Clustering (세션 클러스터링)
    - 클러스터링: 병렬 처리해서 여러 대의 서버를 하나의 서버처럼 운영
    - 세션을 서버 각각에 복사해서 모든 서버가 모든 세션을 보유하고 있음
    - 특정 서버에서 세션이 생성될 때 다른 서버로 세션을 전파하여 복제
- Session Storage (세션 스토리지)
    - 세션만 관리하는 별도의 DB 서버를 두고, 모든 서버가 해당 서버를 참조함

<br/>

**토근 기반 인증 방식**
- 세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에, 최근에는 이를 보완하는 토근 기반의 인증방식을 많이 사용함(`stateless`)
- ex) `JWT(JSON Web Token)` 


<br/>



### 쿠키와 세션의 차이

||쿠키|세션|
|-----|:---------:|:------:|
|저장 위치|클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크|서버 메모리|
|저장 형식|Text|Object|
|만료 시점|쿠키 저장 시 설정|정확한 시점 알 수 없음|
|보안|클라이언트에 저장되므로 취약|Session ID만 저장하고, 이 값에 따라 서버에서 처리하므로  비교적 보안성 좋음|
|속도|클라이언트에 저장되어 서버에 요청 시 빠름|정보가 서버에 저장되어 있어 서버 처리가 필요해 쿠키보다 느림|
|용량 제한|한 도메인 당 20개, 한 쿠키당 4KB|제한없음|

